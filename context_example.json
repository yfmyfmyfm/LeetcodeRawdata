{
    "'''\nGiven a binary tree, find the length of the longest consecutive sequence path.\nThe path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).\nFor example,\n   1\n    \\\n     3\n    / \\\n   2   4\n        \\\n         5\nLongest consecutive sequence path is 3-4-5, so return 3.\n   2\n    \\\n     3\n    / \n   2    \n  / \n 1\nLongest consecutive sequence path is 2-3,not3-2-1, so return 2.\n'''\n": "\n\nclass Solution(object):\n\tdef dfs(curr, parent, length):\n\t\tif not curr:\n\t\t\treturn length\n\t\tif parent:\n\t\t\tlength = length + 1 if curr.val == parent.val + 1\n\t\telse:\n\t\t\tlength = 1\n\n\t\treturn max(length, max(dfs(curr.left, curr, length), dfs(curr.right, curr, length)))\n\n\tdef longestConsecutive(TreeNode root):\n\t\tif not root:\n\t\t\treturn 0\n\n\t\treturn dfs(root, null, 0)\n",
    "'''\n\tGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n\tExample 1:\n\tInput: [1,3,4,2,2]\n\tOutput: 2\n\tExample 2:\n\tInput: [3,1,3,4,2]\n\tOutput: 3\n'''\n": "\nclass Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        slow, fast = nums[0], nums[0]\n        while True:\n        \tslow = nums[slow]\n        \tfast = nums[nums[fast]]\n        \tif slow == fast:\n        \t\tbreak\n\n        num1= nums[0]\n        num2 = slow\n        while num1 != num2:\n        \tnum1 = nums[num1]\n        \tnum2 = nums[num2]\n        return num2",
    "'''\n\tGiven an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\tExample:\n\tInput: [0,1,0,3,12]\n\tOutput: [1,3,12,0,0]\n\tNote:\n\tYou must do this in-place without making a copy of the array.\n\tMinimize the total number of operations.\n'''\n": "\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zeroIndex = 0\n        for index in range(len(nums)):\n            if nums[index] != 0:\n                nums[zeroIndex] = nums[index]\n                zeroIndex += 1\n                \n        for index in range(zeroIndex, len(nums)):\n            nums[index] = 0",
    "'''\n\tFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\tExample 1:\n\tInput: [3,2,1,5,6,4] and k = 2\n\tOutput: 5\n\tExample 2:\n\tInput: [3,2,3,1,2,4,5,5,6] and k = 4\n\tOutput: 4\n'''\n": "\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        heap = []\n        import heapq\n        for num in nums:\n        \theapq.heappush(heap, -(num))\n\n        result = 0\n        for _ in range(k):\n        \tresult = heapq.heappop(heap)\n\n        return -(result)\n",
    "'''\n\tGiven an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\n\tExample:\n\tInput:  [1,2,3,4]\n\tOutput: [24,12,8,6]\n\t 1 1 2 6\n\t \t12 8 6 \n'''\n": "\nclass Solution(object):\n    def productExceptSelf(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n        \treturn []\n\n        dp = [1]*len(nums)\n\n        for index in range(1,len(nums)):\n        \tdp[index] = dp[index-1]*nums[index-1]\n        print dp\n        right = 1\n        for index in range(len(nums)-1, -1, -1):\n        \tdp[index] *= right\n        \tright *= nums[index]\n        return dp",
    "'''\n\tGiven a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n\tExample 1:\n\tInput: n = 12\n\tOutput: 3 \n\tExplanation: 12 = 4 + 4 + 4.\n\tExample 2:\n\tInput: n = 13\n\tOutput: 2\n\tExplanation: 13 = 4 + 9.\n'''\n": "\nclass Solution(object):\n    def numSquares(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        mapping = {}\n        squares = [num*num for num in range(1, int(pow(n, 0.5)) + 1)]\n        for square in squares:\n        \tmapping[square] = 1\n\n        for val in range(1, n+1):\n        \tif val not in mapping:\n        \t\tmapping[val] = float('inf')\n        \t\tfor square in squares:\n        \t\t\tif square < val:\n        \t\t\t\tmapping[val] = min(mapping[val], mapping[square] + mapping[val-square])\n        return mapping[n]",
    "'''\n\tGiven an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n\tExample 1:\n\tInput: [3,0,1]\n\tOutput: 2\n\tExample 2:\n\tInput: [9,6,4,2,3,5,7,0,1]\n\tOutput: 8\n'''\n": "\nclass Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n        \treturn 0\n        totalSum, n = sum(nums), len(nums)\n        expectedSum = (n*(n+1))/2\n        return expectedSum - totalSum",
    "'''\nGiven an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)\nReturn a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.\n'''\n": "\nclass Solution(object):\n    def prefixesDivBy5(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[bool]\n        \"\"\"\n        result = []\n        if not A:\n            return []\n        str_bin = ''\n        for val in A:\n            str_bin += str(val)\n            if(int(str_bin, 2)%5 == 0):\n                result.append(True)\n            else:\n                result.append(False)\n        return result\n",
    "'''\nWe run a preorder depth first search on the root of a binary tree.\nAt each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  (If the depth of a node is D, the depth of its immediate child is D+1.  The depth of the root node is 0.)\nIf a node has only one child, that child is guaranteed to be the left child.\nGiven the output S of this traversal, recover the tree and return its root\n'''\n": "\nclass Solution(object):\n    def longestArithSeqLength(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        from collections import defaultdict\n\n        dp = defaultdict(int)\n        # print dp\n        for index_i in range(len(A)):\n            for index_j in range(index_i):\n                diff = A[index_i] - A[index_j]\n                dp[(index_i, diff)] = max(dp[(index_i, diff)], dp[(index_j, diff)]+1)\n                # print dp\n        return max(dp.itervalues())+1\n",
    "'''\nGiven words first and second, consider occurrences in some text of the form \"first second third\", where second comes immediately after first, and third comes immediately after second.\nFor each such occurrence, add \"third\" to the answer, and return the answer.\n \n'''\n": "\nclass Solution(object):\n    def findOcurrences(self, text, first, second):\n        \"\"\"\n        :type text: str\n        :type first: str\n        :type second: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        if not text:\n            return []\n        splitted_text = text.split(' ')\n        indi = 0\n        for index in range(len(splitted_text)-1):\n            if splitted_text[index] == first and splitted_text[index+1] == second:\n                index = index+2\n                if index < len(splitted_text):\n                    result.append(splitted_text[index])\n        return result\n",
    "'''\nThere are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].\nReturn the minimum cost to fly every person to a city such that exactly N people arrive in each city.\n \n'''\n": "\nclass Solution(object):\n    def twoCitySchedCost(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = 0\n        costs = sorted(costs, key=lambda x : x[0] - x[1])\n        for index in range(len(costs)):\n            if index < len(costs)//2:\n                result += costs[index][0]\n            else:\n                result += costs[index][1]\n        return result\n",
    "'''\nGiven an array A of positive integers (not necessarily distinct), return the lexicographically largest permutation that is smaller than A, that can be made with one swap (A swap exchanges the positions of two numbers A[i] and A[j]).  If it cannot be done, then return the same array.\n \n'''\n": "class Solution(object):\n    def prevPermOpt1(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n    \n        left, right = len(A)-2, len(A)-1\n        for left in range(len(A)-2, -1, -1):\n            if A[left] > A[left+1]:\n                break\n        else:\n            return A\n        right = A.index(max(ele for ele in A[left+1:] if ele < A[left]), left)\n        A[left], A[right] = A[right], A[left]\n        return A\n ",
    "'''\nNormally, the factorial of a positive integer n is the product of all positive integers less than or equal to n.  For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.\nWe instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.\nFor example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.\nAdditionally, the division that we use is floor division such that 10 * 9 / 8 equals 11.  This guarantees the result is an integer.\nImplement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N.\n \n'''\n": "\nclass Solution(object):\n    def clumsy(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        return [0, 1, 2, 6, 7][N] if N < 5 else N + [1, 2, 2, - 1][N % 4]\n",
    "'''\nGiven a binary string S (a string consisting only of '0' and '1's) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.\n \n'''\n": "\nclass Solution(object):\n    def queryString(self, S, N):\n        \"\"\"\n        :type S: str\n        :type N: int\n        :rtype: bool\n        \"\"\"\n        for num in range(1, N+1):\n            binary_str = ''\n            while (num != 0):\n                binary_str += str(num%2)\n                num /= 2\n            reversed_str = binary_str[::-1]\n            \n            if reversed_str not in S:\n                return False\n        return True\n ",
    "'''\nThree stones are on a number line at positions a, b, and c.\nEach turn, let's say the stones are currently at positions x, y, z with x < y < z.  You pick up the stone at either position x or position z, and move that stone to an integer position k, with x < k < z and k != y.\nThe game ends when you cannot make any more moves, ie. the stones are in consecutive positions.\nWhen the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]\n \n'''\n": "\nclass Solution(object):\n    def numMovesStones(self, a, b, c):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: List[int]\n        \"\"\"\n        lista = [a, b, c]\n        lista.sort()\n        a, b, c = lista[0], lista[1], lista[2]\n        minsteps = 0\n        if b == a+1 and c == a+2:\n            return [0, 0]\n        elif b == a+1 or c == b+1 or c == b+2 or  b == a+2:\n            minsteps = 1\n        else:\n            minsteps = 2\n        return [minsteps, b-a-1+c-b-1]\n",
    "'''\nGiven a number N, return a string consisting of \"0\"s and \"1\"s that represents its value in base -2 (negative two).\nThe returned string must have no leading zeroes, unless the string is \"0\".\n'''\n": "\nclass Solution(object):\n    def baseNeg2(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: str\n        \"\"\"\n        if N == 0:\n            digits = ['0']\n        else:\n            digits = []\n            while N != 0:\n                N, remainder = divmod(N, -2)\n                if remainder < 0:\n                    N, remainder = N+1, remainder + 2\n                digits.append(str(remainder))\n        return ''.join(digits[::-1])\n",
    "'''\nWe have a collection of rocks, each rock has a positive integer weight.\nEach turn, we choose the two heaviest rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:\nIf x == y, both stones are totally destroyed;\nIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\nAt the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)\n \n'''\n": "\nclass Solution(object):\n    def lastStoneWeight(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        while len(stones) > 1:\n            max_x = max(stones)\n            stones.remove(max_x)\n            max_y = max(stones)\n            stones.remove(max_y)\n            \n            if max_x != max_y:\n                stones.append(max_x-max_y)\n        return stones[0] if stones else 0\n",
    "'''\nA boomerang is a set of 3 points that are all distinct and not in a straight line.\nGiven a list of three points in the plane, return whether these points are a boomerang.\n \n'''\n": "\nclass Solution(object):\n    def isBoomerang(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        x1, x2, x3, y1, y2, y3 = points[0][0], points[1][0], points[2][0], points[0][1], points[1][1] ,points[2][1]\n        if ((y3 - y2)*(x2 - x1) == (y2 - y1)*(x3 - x2)):\n            return False\n        return True\n",
    "'''\nGiven an array A of integers, return the length of the longest arithmetic subsequence in A.\nRecall that a subsequence of A is a list A[i_1], A[i_2], ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 <= i < B.length - 1).\n \n'''\n": "\nclass Solution(object):\n    def longestArithSeqLength(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        from collections import defaultdict\n\n        dp = defaultdict(int)\n        # print dp\n        for index_i in range(len(A)):\n            for index_j in range(index_i):\n                diff = A[index_i] - A[index_j]\n                dp[(index_i, diff)] = max(dp[(index_i, diff)], dp[(index_j, diff)]+1)\n                # print dp\n        return max(dp.itervalues())+1\n",
    "'''\nGiven an array A of positive integers, let S be the sum of the digits of the minimal element of A.\nReturn 0 if S is odd, otherwise return 1.\n \n'''\n": "class Solution(object):\n    def sumOfDigits(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if not A:\n            return 0\n        \n        mini = min(A)\n        result = 0\n        while mini > 0:\n            quo = mini%10\n            rem = mini/10\n            result += quo\n            mini = rem\n            \n        return 0 if result%2 else 1\n",
    "'''\nGiven an array A of 0s and 1s, we may change up to K values from 0 to 1.\nReturn the length of the longest (contiguous) subarray that contains only 1s. \n \n'''\n": "\nclass Solution(object):\n    def longestOnes(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        start_index = 0\n        for end_index in range(0, len(A)):\n            K -= 1-A[end_index]\n            if K < 0:\n                K += 1-A[start_index]\n                start_index += 1\n        return end_index-start_index+1\n",
    "'''\nGiven an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.\nThe score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.\nReturn the maximum score of a pair of sightseeing spots.\n \n'''\n": "class Solution(object):\n    def maxScoreSightseeingPair(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        prev_best, result = 0, 0\n        for index in range(0, len(A)):\n            result = max(result, A[index]-index+prev_best)\n            prev_best = max(prev_best, A[index]+index)\n        return result\n ",
    "'''\nGiven a text string and words (a list of strings), return all index pairs [i, j] so that the substring text[i]...text[j] is in the list of words.\n \n'''\n": "\nclass Solution(object):\n    def indexPairs(self, text, words):\n        \"\"\"\n        :type text: str\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not words:\n            return []\n        result = []\n        for word in words:\n            starting = [index for index in range(len(text)) if text.startswith(word, index)]\n            for start in starting:\n                result.append([start, start+len(word)-1])\n            # print starting\n        result.sort()\n        return result\n            ",
    "'''\nStudents are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)\n \n'''\n": "\nclass Solution(object):\n    def heightChecker(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for new_h, hei in zip(heights, sorted(heights)):\n            if new_h != hei:\n                result += 1\n        return result\n",
    "'''\nGiven an array A of distinct integers sorted in ascending order, return the smallest index i that satisfies A[i] == i.  Return -1 if no such i exists.\n \n'''\n": "\nclass Solution(object):\n    def fixedPoint(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if not A:\n            return -1\n        for index, num in enumerate(A):\n            if num == index:\n                return index\n        return -1\n",
    "'''\nGiven an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.)\nReturn the largest possible sum of the array after modifying it in this way.\n \n'''\n": "\nclass Solution(object):\n    def largestSumAfterKNegations(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        A.sort()\n        index = 0\n        while K > 0:\n            if A[index] < 0:\n                A[index] *= -1\n                if A[index+1] < A[index] and index < len(A)-1:\n                    index += 1\n            else:\n                A[index] *= -1\n            K -= 1\n        return sum(A)\n",
    "'''\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\n \n'''\n": "\nclass Solution(object):\n    def removeOuterParentheses(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        temp, result = \"\", \"\"\n        start_bracket = 0\n        for char in S:\n            temp += char\n            if char == '(':\n                start_bracket += 1\n            else:\n                start_bracket -= 1\n            if start_bracket == 0:\n                result += temp[1:-1]\n                temp = \"\"\n        return result\n",
    "'''\nGiven a positive integer K, you need find the smallest positive integer N such that N is divisible by K, and N only contains the digit 1.\nReturn the length of N.  If there is no such N, return -1.\n \n'''\n": "\nclass Solution(object):\n    def smallestRepunitDivByK(self, K):\n        \"\"\"\n        :type K: int\n        :rtype: int\n        \"\"\"\n        length, value = 0, 0\n        for no_one in range(100000):\n            value = (10*value + 1)%K\n            length += 1\n            if value == 0:\n                return length\n        return -1\n",
    "'''\nGiven a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.\nNote that elements beyond the length of the original array are not written.\nDo the above modifications to the input array in place, do not return anything from your function.\n \n'''\n": "\nclass Solution(object):\n    def duplicateZeros(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: None Do not return anything, modify arr in-place instead.\n        \"\"\"\n        arr_copy = arr[:]\n        index, n = 0, len(arr_copy)\n        for elem in arr_copy:\n            arr[index] = elem\n            index += 1\n            if index >= n:\n                break\n            if elem == 0:\n                arr[index] = elem\n                index += 1\n                if index >= n:\n                    break\n",
    "'''\nIn a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.\nTrain tickets are sold in 3 different ways:\na 1-day pass is sold for costs[0] dollars;\na 7-day pass is sold for costs[1] dollars;\na 30-day pass is sold for costs[2] dollars.\nThe passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n \n'''\n": "\nclass Solution:\n    def mincostTickets(self, days: 'List[int]', costs: 'List[int]') -> 'int':\n        def get_days_ago(day, ago):\n            for i in range(len(days)):\n                if days[i] > days[day-1] - ago:\n                    return i\n        out = [0] * (len(days) + 1)\n        for i in range(1, len(days) + 1):\n            out[i] = min(out[i-1] + costs[0], out[get_days_ago(i,7)] + costs[1], out[get_days_ago(i,30)] + costs[2])\n        return out[-1]\n",
    "'''\nIn an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.\nInput: A = [0,1,0], K = 1\nOutput: 2\nExplanation: Flip A[0], then flip A[2]\n'''\n": "\nclass Solution:\n    def minKBitFlips(self, a: 'List[int]', k: 'int') -> 'int':\n        from collections import deque\n        q = deque()\n        res = 0\n        for i in range(len(a)):\n            if len(q) % 2 != 0:\n                if a[i] == 1:\n                    res += 1\n                    q.append(i+k-1)\n            else:\n                if a[i] == 0:\n                    res += 1\n                    q.append(i+k-1)\n            if q and q[0] == i: q.popleft()\n            if q and q[-1] >= len(a): return -1\n        return res    ",
    "'''\nOn a broken calculator that has a number showing on its display, we can perform two operations:\nDouble: Multiply the number on the display by 2, or;\nDecrement: Subtract 1 from the number on the display.\nInitially, the calculator is displaying the number X.\nReturn the minimum number of operations needed to display the number Y.\n \n'''\n": "\nclass Solution(object):\n    def brokenCalc(self, X, Y):\n        \"\"\"\n        :type X: int\n        :type Y: int\n        :rtype: int\n        \"\"\"\n        if X == Y:\n            return 0\n        if X > Y:\n            return X-Y\n        if(Y%2 == 1):\n            return 1 + self.brokenCalc(X, Y+1)\n        else:\n            return 1 + self.brokenCalc(X, Y/2)\n",
    "'''\nA string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)\nWe are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.\nReturn the minimum number of flips to make S monotone increasing.\n \n'''\n": "\nclass Solution(object):\n    def minFlipsMonoIncr(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        ones = [0]\n        for char in S:\n            ones.append(ones[-1] + int(char))\n        # print ones\n        result = float('inf')\n        for index in range(len(ones)):\n            zeroes = len(S) - index - (ones[-1]-ones[index])\n            result = min(zeroes+ones[index], result)\n        return result\n",
    "'''\nGiven an unsorted array of integers, find the number of longest increasing subsequence.\n'''\n": "\nclass Solution(object):\n    def findNumberOfLIS(self, nums):\n        length = [1]*len(nums)\n        count = [1]*len(nums)\n        result = 0\n        for end, num in enumerate(nums):\n            for start in range(end):\n                if num > nums[start]:\n                    if length[start] >= length[end]:\n                        length[end] = 1+length[start]\n                        count[end] = count[start]\n                    elif length[start] + 1 == length[end]:\n                        count[end] += count[start]\n        for index, max_subs in enumerate(count):\n            if length[index] == max(length):\n                result += max_subs\n        return result\n",
    "'''\nGiven a time represented in the format \"HH:MM\", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.\nYou may assume the given input string is always valid. For example, \"01:34\", \"12:09\" are all valid. \"1:34\", \"12:9\" are all invalid.\n'''\n": "\nclass Solution(object):\n    def nextClosestTime(self, time):\n    \tcurrent_time = 60*int(time[:2]) + int(time[3:])\n    \tallowed = {int(x) for x in time if x != ':'}\n    \tresult = 24*60\n    \tans = current_time\n    \tfor h1, h2, m1, m2 in itertools.product(allowed, repeat=4):\n    \t\thours, minutes = 10*h1+h2, 10*m1+m2\n    \t\tif hours < 24 and minutes < 60:\n    \t\t\telapsed = 60*hours + minutes\n    \t\t\tdiff = (current_time - elapsed)%(24*60)\n    \t\t\tif 0 < diff < result:\n    \t\t\t\tresult = diff\n    \t\t\t\tans = elapsed\n\n    \treturn \"{:02d}:{:02d}\".format(divmod(ans, 60))\n",
    "'''\nGiven an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).\n'''\n": "\nclass Solution(object):\n    def findLengthOfLCIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        start, result = 0, 1\n        for end in range(1, len(nums)):\n            if nums[end-1] >= nums[end]:\n                start = end\n            result = max(result, end-start+1)\n        return result\n",
    "'''\nSuppose we abstract our file system by a string in the following manner:\nThe string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents:\ndir\n    subdir1\n    subdir2\n        file.ext\nThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.\nThe string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents:\ndir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\nThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.\nWe are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is \"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not including the double quotes).\nGiven a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.\nNote:\nThe name of a file contains at least a . and an extension.\nThe name of a directory or sub-directory will not contain a ..\nTime complexity required: O(n) where n is the size of the input string.\nNotice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png\n'''\n": "\nclass Solution(object):\n    def lengthLongestPath(self, input):\n        \"\"\"\n        :type input: str\n        :rtype: int\n        \"\"\"\n        if not input:\n            return 0\n        directories = input.split('\\n')\n        stack = [[-1, 0]] # \\t level, total dir length\n        result = 0\n        for direct in directories:\n            n_tabs = direct.count('\\t')\n            while stack and stack[-1][0] >= n_tabs:\n                stack.pop()\n            if \".\" in direct:\n                result = max(result, stack[-1][1] + len(direct)-n_tabs)\n            stack.append([n_tabs, stack[-1][1] + len(direct) + 1 -n_tabs])\n        return result\n",
    "'''\n\tGiven a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n\tExamples:\n\ts = \"leetcode\"\n\treturn 0.\n\ts = \"loveleetcode\",\n\treturn 2.\n'''\n": "\nclass Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        letters='abcdefghijklmnopqrstuvwxyz'\n        index=[s.index(l) for l in letters if s.count(l) == 1]\n        return min(index) if len(index) > 0 else -1",
    "'''\n\tGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\n\tFormally the function should:\n\tReturn true if there exists i, j, k \n\tsuch that arr[i] < arr[j] < arr[k] given 0 \u2264 i < j < k \u2264 n-1 else return false.\n\tYour algorithm should run in O(n) time complexity and O(1) space complexity.\n\tExamples:\n\tGiven [1, 2, 3, 4, 5],\n\treturn true.\n\tGiven [5, 4, 3, 2, 1],\n\treturn false.\n'''\n": "\nclass Solution(object):\n    def increasingTriplet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        first, second = float('inf'), float('inf')\n        for val in nums:\n        \tif val <= first:\n        \t\tfirst = val\n        \telif val <= second:\n        \t\tsecond = val\n        \telse:\n        \t\treturn True\n\n        return False",
    "'''\n\tYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\tExample 1:\n\tcoins = [1, 2, 5], amount = 11\n\treturn 3 (11 = 5 + 5 + 1)\n\tExample 2:\n\tcoins = [2], amount = 3\n\treturn -1.\n'''\n": "\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        if not coins:\n        \treturn 0\n\n        dp = [float('inf') for _ in range(amount+1)]\n        dp[0] = 0\n\n        for val in range(1, amount+1):\n        \tfor coin in coins:\n        \t\tif coin <= val:\n        \t\t\tdp[val] = min(dp[val-coin]+1, dp[val])\n        return dp[amount] if dp[amount] != float('inf') else -1",
    "'''\n\tGiven an integer, write a function to determine if it is a power of three.\n\tFollow up:\n\tCould you do it without using any loop / recursion?\n'''\n": "\nclass Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n        \treturn False\n\n        import math\n        return (math.log10(n)/math.log10(3))%1 == 0",
    "'''\nYou are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.\nGiven a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.\nGiven a non-empty string S and a number K, format the string according to the rules described above.\n'''\n": "\nclass Solution(object):\n    def licenseKeyFormatting(self, S, K):\n        \"\"\"\n        :type S: str\n        :type K: int\n        :rtype: str\n        \"\"\"\n        S = S.replace('-','').upper()\n        result = \"\"\n        \n        if len(S)%K == 0:\n            for index in range(0, len(S), K):\n                result += S[index:index+K] + \"-\"\n        else:\n            result = S[:len(S)%K] + \"-\"\n            for index in range(len(S)%K, len(S), K):\n                result += S[index:index+K] + \"-\"\n        return result[:-1]\n",
    "'''\nGiven an array of integers where 1 \u2264 a[i] \u2264 n (n = size of array), some elements appear twice and others appear once.\nFind all the elements of [1, n] inclusive that do not appear in this array.\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\n'''\n": "\nclass Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n        result = []\n        for num in nums:\n            index = abs(num)-1\n            if nums[index] > 0:\n                nums[index]*=-1\n        for index, num in enumerate(nums):\n            if num >0:\n                result.append(index+1)\n        return result\n",
    "'''\nGiven an array of integers, 1 \u2264 a[i] \u2264 n (n = size of array), some elements appear twice and others appear once.\nFind all the elements that appear twice in this array.\nCould you do it without extra space and in O(n) runtime?\n'''\n": "\nclass Solution(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n        \n        result = []\n        for _, num in enumerate(nums):\n            index = abs(num)-1\n            if nums[index] < 0:\n                result.append(index+1)\n            nums[index]*=-1\n        return result\n",
    "'''\n\tGiven a non-negative index k where k \u2264 33, return the kth index row of the Pascal's triangle.\n\tNote that the row index starts from 0.\n'''\n": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        row = [1]*(rowIndex+1)\n        for i in range(1, rowIndex+1):\n        \tfor j in range(i-1, 0, -1):\n        \t\trow[j] += row[j-1]\n        return row",
    "'''\n\tGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\tNote:\n\tThe same word in the dictionary may be reused multiple times in the segmentation.\n\tYou may assume the dictionary does not contain duplicate words.\n\tExample 1:\n\tInput: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n\tOutput: true\n\tExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\n'''\n": "\nclass Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        dp = [False for _ in range(len(s)+1)]\n        dp[0] = True\n        for index in range(len(s)):\n        \tfor j in range(i, -1, -1):\n        \t\tif dp[j] and s[j:i+1] in wordDict:\n        \t\t\tdp[i+1] = True\n        \t\t\tbreak\n        return dp[len(s)]",
    "'''\n\tGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\tYour algorithm should run in O(n) complexity.\n\tExample:\n\tInput: [100, 4, 200, 1, 3, 2]\n\tOutput: 4\n\tExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n'''\n": "\nclass Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        nums = set(nums)\n\n        for num in nums:\n        \tif num-1 not in nums:\n        \t\tcurr = num\n        \t\tlength = 1\n\n        \t\twhile curr+1 in nums:\n        \t\t\tcurr += 1\n        \t\t\tlength += 1\n        \t\tresult = max(result, length)\n        return result",
    "'''\n\tGiven a non-negative integer numRows, generate the first numRows of Pascal's triangle.\n\tExample:\n\tInput: 5\n\tOutput:\n\t[\n\t     [1],\n\t    [1,1],\n\t   [1,2,1],\n\t  [1,3,3,1],\n\t [1,4,6,4,1]\n\t]\n'''\n": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        triangle = []\n\n        for row in range(numRows):\n        \tnew_row = [0 for _ in range(row+1)]\n        \tnew_row[0], new_row[-1] = 1, 1\n\n        \tfor col in range(1, len(new_row)-1):\n        \t\tnew_row[col] = triangle[row-1][col-1] + triangle[row-1][col]\n        \ttriangle.append(new_row)\n        return triangle",
    "'''\n\tSay you have an array for which the ith element is the price of a given stock on day i.\n\tDesign an algorithm to find the maximum profit. You may complete at most two transactions.\n\tNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\tExample 1:\n\tInput: [3,3,5,0,0,3,1,4]\n\tOutput: 6\n\tExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\t             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n'''\n": "\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if len(prices) < 2:\n        \treturn 0\n        dp = [[0 for _ in range(len(prices))] for _ in range(3)]\n        for i in range(1,3):\n        \tmaxDiff = -prices[0]\n        \tfor j in range(1,len(prices)):\n        \t\tdp[i][j] = max(dp[i][j-1], prices[j] + maxDiff)\n        \t\tmaxDiff = max(maxDiff, dp[i-1][j] -prices[j])\n\n        return dp[2][len(prices)-1]\n\n",
    "'''\n\tGiven a string s, partition s such that every substring of the partition is a palindrome.\n\tReturn all possible palindrome partitioning of s.\n'''\n": "\nclass Solution(object):\n    def partition(self, s):\n    \tresult = []\n    \tdef valid(s):\n    \t\tfor i in range(len(s)/2):\n    \t\t\tif s[i] != s[-(i+1)]:\n    \t\t\t\treturn False\n    \t\treturn True\n\n    \tdef partitionRec(curr, s, i):\n    \t\tif i == len(s):\n    \t\t\tresult.append(curr)\n    \t\telse:\n    \t\t\tfor j in range(i, len(s)):\n    \t\t\t\tif valid(s[i:j+1]):\n    \t\t\t\t\tpartitionRec(curr + [s[i:j+1]], s, j+1)\n\n    \tpartitionRec([], s, 0)\n    \treturn result",
    "'''\nThere are n people whose IDs go from 0 to n - 1 and each person belongs exactly to one group. Given the array groupSizes of length n telling the group size each person belongs to, return the groups there are and the people's IDs each group includes.\nYou can return any solution in any order and the same applies for IDs. Also, it is guaranteed that there exists at least one solution. \n \n'''\n": "class Solution(object):\n    def groupThePeople(self, groupSizes):\n        \"\"\"\n        :type groupSizes: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        count = collections.defaultdict(list)\n        for i, size in enumerate(groupSizes):\n            count[size].append(i)\n        result = []\n        for s, value in count.items():\n            for index in range(0, len(value), s):\n                result.append(value[index:index + s])\n        return result\n",
    "'''\nGiven an array of integers nums and a positive integer k, find whether it's possible to divide this array into sets of k consecutive numbers\nReturn True if its possible otherwise return False.\n \n'''\n": "class Solution(object):\n    def isPossibleDivide(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        from collections import Counter\n        count_map = Counter(nums)\n        for num in sorted(count_map.keys()):\n            if count_map[num] <= 0:\n                continue\n            for index in range(1, k):\n                count_map[num+index] -= count_map[num]\n                if count_map[num+index] < 0:\n                    return False\n        return True\n",
    "'''\nGiven an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).\nIt is guaranteed that there will be an answer.\n \n'''\n": "class Solution(object):\n    def smallestDivisor(self, nums, threshold):\n        \"\"\"\n        :type nums: List[int]\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        def getSum(divisor, xs):\n            return sum([x // divisor + 1 if x % divisor else x // divisor for x in xs])\n\t\t\n        left, right = 1, 10 ** 6\n        while left + 1 < right:\n            mid = (left + right) // 2            \n            if getSum(mid, nums) > threshold: \n                left = mid\n            else: \n                right = mid\n        \n        return left if getSum(left, nums) <= threshold else right\n",
    "'''\nGiven a m * n matrix of ones and zeros, return how many square submatrices have all ones.\n \n'''\n": "class Solution(object):\n    def countSquares(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"  \n    \n        p_arr = [[0 for i in range(len(matrix[0]))] for j in range(len(matrix))]  \n        result = 0\n\n        for index_i in range(1, len(matrix)):\n            for index_j in range(1, len(matrix[0])):\n                if matrix[index_i][index_j] == 1:\n                    matrix[index_i][index_j] = min(matrix[index_i-1][index_j-1], min(matrix[index_i-1][index_j], matrix[index_i][index_j-1]))+1\n        # print p_arr\n        return sum([ sum(x) for x in matrix])  ",
    "'''\nGiven head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.\nReturn the decimal value of the number in the linked list.\n \n'''\n": "\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getDecimalValue(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        result = ''\n        if not head:\n            return 0\n        while head:\n            result+= str(head.val)\n            head = head.next\n        return int(result, 2)\n",
    "'''\nGiven an integer number n, return the difference between the product of its digits and the sum of its digits.\n \n'''\n": "\nclass Solution(object):\n    def subtractProductAndSum(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        from functools import reduce\n        from operator import mul\n        digits = [int(x) for x in str(n)]\n        return reduce(mul, digits) - sum(digits)\n",
    "'''\nGiven two integers tomatoSlices and cheeseSlices. The ingredients of different burgers are as follows:\nJumbo Burger: 4 tomato slices and 1 cheese slice.\nSmall Burger: 2 Tomato slices and 1 cheese slice.\nReturn [total_jumbo, total_small] so that the number of remaining tomatoSlices equal to 0 and the number of remaining cheeseSlices equal to 0. If it is not possible to make the remaining tomatoSlices and cheeseSlices equal to 0 return [].\n \n'''\n": "class Solution(object):\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\n        \"\"\"\n        :type tomatoSlices: int\n        :type cheeseSlices: int\n        :rtype: List[int]\n        \"\"\"\n        jumbo = tomatoSlices - 2*cheeseSlices\n        if jumbo >= 0 and jumbo%2 == 0:\n            x = jumbo/2\n            y = cheeseSlices-(jumbo/2)\n            if x >= 0 and y >= 0:\n                return [x, y]\n            else:\n                return []\n        return []\n        ",
    "'''\nOn a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.\nYou can move according to the next rules:\nIn one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second).\nYou have to visit the points in the same order as they appear in the array.\nInput: points = [[1,1],[3,4],[-1,0]]\nOutput: 7\nExplanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   \nTime from [1,1] to [3,4] = 3 seconds \nTime from [3,4] to [-1,0] = 4 seconds\nTotal time = 7 seconds\n'''\n": "\nclass Solution(object):\n    def minTimeToVisitAllPoints(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not points:\n            return 0\n        result = 0\n        for index in range(1, len(points)):\n            result += max(abs(points[index][0]-points[index-1][0]), abs(points[index][1]-points[index-1][1]))\n        return result\n",
    "'''\nGiven an array nums of integers, return how many of them contain an even number of digits.\n \n'''\n": "class Solution(object):\n    def findNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return len([num for num in nums if len(str(num))%2 == 0])",
    "'''\n\tYou are climbing a stair case. It takes n steps to reach to the top.\n\tEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\tNote: Given n will be a positive integer.\n\tExample 1:\n\tInput: 2\n\tOutput: 2\n\tExplanation: There are two ways to climb to the top.\n\t1. 1 step + 1 step\n\t2. 2 steps\n'''\n": "\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n        \treturn 0\n\n        dp = [0]*n\n        dp[0], dp[1] = 1, 2\n\n        for index in range(2, n):\n        \tdp[index] = dp[index-1] + dp[index-2]\n        return dp[n-1]\n\n# Time: O(N)\n# Space: O(N)\n",
    "'''\n\tGiven n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\tNote: You may not slant the container and n is at least 2.\n'''\n": "\nclass Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        left, right, maxArea = 0, len(height) - 1, 0 \n\n        while left < right:\n        \tmaxArea = max(maxArea, min(height[left], height[right])*(right-left))\n        \tif height[left] < height[right]:\n        \t\tleft += 1\n        \telse:\n        \t\tright -= 1\n\n        return maxArea \n\n# Space : O(1)\n# Time: O(N)",
    "'''\n\tWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n\tIntegers in each row are sorted from left to right.\n\tThe first integer of each row is greater than the last integer of the previous row.\n\tExample 1:\n\tInput:\n\tmatrix = [\n\t  [1,   3,  5,  7],\n\t  [10, 11, 16, 20],\n\t  [23, 30, 34, 50]\n\t]\n\ttarget = 3\n\tOutput: true\n'''\n": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n\n        if not matrix:\n        \treturn 0\n        left, right = 0, len(matrix[0])-1\n\n        while left < len(matrix) and right >= 0:\n        \tif matrix[left][right] == target:\n        \t\treturn True \n        \telif matrix[left][right] < target:\n        \t\tleft += 1\n        \telse:\n        \t\tright -= 1\n        return False",
    "'''\n\tValidate if a given string is numeric.\n\tSome examples:\n\t\"0\" => true\n\t\" 0.1 \" => true\n\t\"abc\" => false\n\t\"1 a\" => false\n\t\"2e10\" => true\n\tNote: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.\n'''\n": "\nclass Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        s = s.strip()\n        try:\n            if isinstance(float(s),float) or isinstance(int(s),int):\n                return True\n        except Exception as e:\n            return False\n\n# Time: O(1)\n# Space: O(1)",
    "'''\n\tGiven an unsorted integer array, find the smallest missing positive integer.\n\tExample 1:\n\tInput: [1,2,0]\n\tOutput: 3\n\tExample 2:\n\tInput: [3,4,-1,1]\n\tOutput: 2\n\tExample 3:\n\tInput: [7,8,9,11,12]\n\tOutput: 1\n'''\n": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        index_i = 0\n        for index_j in range(len(nums)):\n        \tif nums[index_j] <= 0:\n        \t\tnums[index_i], nums[index_j] = nums[index_j], nums[index_i]\n        \t\tindex_i += 1\n\n        for index in range(index_i, len(nums)):\n        \tif abs(nums[index]) - 1 < len(nums) and nums[abs(nums[index]) - 1] > 0:\n        \t\tnums[abs(nums[index]) - 1] =  -nums[abs(nums[index]) - 1]\n\n        for index in range(nums):\n        \tif nums[index] > 0:\n        \t\treturn index + 1\n        return len(nums) + 1",
    "'''\n\tGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n\tHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n\tNote: You are not suppose to use the library's sort function for this problem.\n\tExample:\n\tInput: [2,0,2,1,1,0]\n\tOutput: [0,0,1,1,2,2]\n'''\n": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero, last = 0, len(nums)-1\n        index = 0\n        while  index <= last:\n        \tif nums[index] == 1:\n        \t\tindex += 1\n        \telif nums[index] == 0:\n        \t\tnums[index], nums[zero] = nums[zero], nums[index]\n        \t\tindex += 1\n        \t\tzero += 1\n        \telif nums[index] == 2:\n        \t\tnums[last], nums[index] = nums[index], nums[last]\n        \t\tlast -= 1",
    "'''\n\tGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\n\tYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\tExample:\n\tGiven nums = [2, 7, 11, 15], target = 9,\n\tBecause nums[0] + nums[1] = 2 + 7 = 9,\n\treturn [0, 1].\n'''\n": "\nclass Solution(object):\n\tdef twoSum(self, nums, target):\n\t\tmapping = {}\n\n\t\tfor index, val in enumerate(nums):\n\t\t\tdiff = target - val\n\t\t\tif diff in mapping:\n\t\t\t\treturn [index, mapping[diff]]\n\t\t\telse:\n\t\t\t\tmapping[val] = index\n\n# Space: O(N)\n# Time: O(N)\n",
    "'''\n\tYou are given an n x n 2D matrix representing an image.\n\tRotate the image by 90 degrees (clockwise).\n'''\n": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        if n%2 == 0:\n        \tm = n/2\n        else:\n        \tm = n/2 + 1\n\n        for i in range(n/2):\n        \tfor j in range(m):\n        \t\ttemp = matrix[i][j]\n        \t\tmatrix[i][j] = matrix[n-j-1][i]\n        \t\tmatrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n        \t\tmatrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n        \t\tmatrix[j][n-i-1] = temp\n",
    "'''\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\n'''\n": "\nclass Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = [[]]\n        for num in nums:\n        \tfor j in range(len(result)):\n        \t\tresult.append(result[j] + [num])\n        return result",
    "'''\n\tGiven a string, find the length of the longest substring without repeating characters.\n\tExamples:\n\tGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\n\tGiven \"bbbbb\", the answer is \"b\", with the length of 1.\n\tGiven \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n'''\n": "\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        mapSet = {}\n        start, result = 0, 0\n\n        for end in range(len(s)):\n        \tif s[end] in mapSet:\n        \t\tstart = max(mapSet[s[end]], start)\n        \tresult = max(result, end-start+1)\n        \tmapSet[s[end]] = end+1\n\n        return result ",
    "'''\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nHow many possible unique paths are there?\n'''\n": "\nclass Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for index in range(m):\n        \tdp[index][0] = 1\n\n        for index in range(n):\n        \tdp[0][index] = 1\n\n        for index_i in range(1, m):\n        \tfor index_j in range(1, n):\n        \t\tdp[index_i][index_j] = dp[index_i-1][index_j] + dp[index_i][index_j-1]\n\n        return dp[m-1][n-1]",
    "'''\n\tGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\n\t\tNote: The solution set must not contain duplicate subsets.\n\t\tExample:\n\t\tInput: [1,2,2]\n\t\tOutput:\n\t\t[\n\t\t  [2],\n\t\t  [1],\n\t\t  [1,2,2],\n\t\t  [2,2],\n\t\t  [1,2],\n\t\t  []\n\t\t]\n'''\n": "\nclass Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"   \n        result = [[]]\n        for num in nums:\n        \tfor index in range(len(result)):\n        \t\tnew_list = result[index] + [num]\n        \t\tnew_list.sort()\n        \t\tresult.append(new_list)\n        unique = set(tuple(val) for val in result)\n        return list(list(val) for val in unique)",
    "'''\n\tGiven a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\n\tDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n\tExample 1:\n\tGiven nums = [1,1,1,2,2,3],\n\tYour function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\n\tIt doesn't matter what you leave beyond the returned length.\n'''\n": "\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) <= 2:\n        \treturn len(nums)\n\n        prev, curr = 1, 2\n\n        while curr < len(nums):\n        \tif nums[prev] == nums[curr] and nums[curr] == nums[prev-1]:\n        \t\tcurr += 1\n        \telse:\n        \t\tprev += 1\n        \t\tnums[prev] = nums[curr]\n        \t\tcurr += 1\n        return prev+1\n",
    "'''\n\tGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\tExample:\n\tInput: [-2,1,-3,4,-1,2,1,-5,4],\n\tOutput: 6\n\tExplanation: [4,-1,2,1] has the largest sum = 6.\n'''\n": "\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n        \treturn 0\n\n        currSum, result = nums[0], nums[0]\n\n        for index in range(1, len(nums)):\n        \tcurrSum = max(nums[index], currSum+nums[index])\n        \tresult = max(result, currSum)\n\n        return result",
    "'''\n\tGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\n\tDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n\tExample 1:\n\tGiven nums = [1,1,2],\n\tYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\tIt doesn't matter what you leave beyond the returned length.\n'''\n": "\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n        \treturn 0\n        \t\n        index_i = 0\n\n        for index_j in range(1, len(nums)):\n        \tif nums[index_i] != nums[index_j]:\n        \t\tindex_i += 1\n        \t\tnums[index_i] = nums[index_j]\n\n        return index_i + 1",
    "'''\nGiven a date, return the corresponding day of the week for that date.\nThe input is given as three integers representing the day, month and year respectively.\nReturn the answer as one of the following values {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}.\n \n'''\n": "class Solution(object):\n    def dayOfTheWeek(self, day, month, year):\n        \"\"\"\n        :type day: int\n        :type month: int\n        :type year: int\n        :rtype: str\n        \"\"\"\n        day_of_week_map = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        t = [ 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 ] \n        year -= month < 3\n        return day_of_week_map[((year  + int(year / 4) - int(year / 100) + int(year / 400) + t[month - 1] + day) % 7)]\n",
    "'''\nA bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.\nThe bus goes along both directions i.e. clockwise and counterclockwise.\nReturn the shortest distance between the given start and destination stops.\n \n'''\n": "\nclass Solution(object):\n    def distanceBetweenBusStops(self, distance, start, destination):\n        \"\"\"\n        :type distance: List[int]\n        :type start: int\n        :type destination: int\n        :rtype: int\n        \"\"\"\n        start, destination = min(start, destination), max(start, destination)\n        clock_dist = sum(distance[start:destination])\n        anti_clock_dist = sum(distance[:start]) + sum(distance[destination:])\n        return min(clock_dist, anti_clock_dist)\n",
    "'''\nGiven a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\n \n'''\n": "\nclass Solution(object):\n    def maxNumberOfBalloons(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        if not text:\n            return 0\n        \n        import collections\n        cnt = collections.Counter(text)\n        cnt_ballon = collections.Counter('balloon')\n        \n        return min([cnt[c]//cnt_ballon[c] for c in cnt_ballon])\n"
}